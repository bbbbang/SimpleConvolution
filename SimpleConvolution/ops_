#pragma once

#include "utils.h"

#include <chrono>
#include <cmath>
#include <iostream>
#include <algorithm>

void Relu(Tensor* inputData);
void ZeroConcat(Tensor* inputData);
void Softmax(Tensor* inputData);

void ZeroPadding(Tensor* inputData, int padding);
void MaxPool(Tensor* inputData, int kernel, int stride, int padding);
void Resize(Tensor* inputData, float scale);


void Add(Tensor* inputData, Tensor* outputData);
void Concat(Tensor* inputData, Tensor* outputData);


void Relu(Tensor* inputData)
{
	float* data = inputData->data;
	int size = inputData->width * inputData->height * inputData->channel;

	for (int i = 0; i < size; ++i)
	{
		data[i] = (data[i] < 0) ? 0 : data[i];
	}
}
void ZeroConcat(Tensor* inputData)
{
	float* data = inputData->data;
	int size = inputData->width * inputData->height * inputData->channel;

	for (int i = size; i < size * 2; ++i)
	{
		data[i] = 0;
	}
}
void Softmax(Tensor* inputData)
{
	int channel = inputData->channel;
	float sum = 0;
	float* data = inputData->data;

	for (int i = 0; i < channel; ++i)
	{
		float val = std::exp(data[i]);

		data[i] = val;
		sum += val;
	}
	for (int i = 0; i < channel; ++i)
	{
		data[i] = data[i] / sum;
	}
}

void ZeroPadding(Tensor* inputData, int padding)
{
	int height = inputData->height;
	int width = inputData->width;
	int channel = inputData->channel;
	int area = height * width;

	int outputWidth = (height + padding * 2);
	int outputArea = outputWidth * outputWidth;

	float* data = inputData->data;

	float* tempData = new float[area * channel];
	memcpy(tempData, data, sizeof(float) * area * channel);
	memset(data, 0, sizeof(float) * area * channel);

	for (int ch = 0; ch < channel; ++ch)
	{
		tempData += outputWidth;
		for (int row = 0; row < height; ++row)
		{
			++tempData;
			for (int col = 0; col < width; ++col)
			{
				*data = *tempData;

				++data;
				++tempData;
			}
			++tempData;
		}
		tempData += outputWidth;
	}

	inputData->height = outputWidth;
	inputData->width = outputWidth;

	delete[] tempData;
}
void MaxPool(Tensor* inputData, int kernel, int stride, int padding)
{
	int height = inputData->height;
	int width = inputData->width;
	int channel = inputData->channel;
	int area = height * width;

	int padHeight = height + padding * 2;
	int padWidth = width + padding * 2;

	int outputHeight = (padHeight - kernel) / stride + 1;
	int outputWidth = (padWidth - kernel) / stride + 1;

	float* data = inputData->data;

	float* tempData = new float[area * channel];
	memcpy(tempData, data, sizeof(float) * area * channel);
	memset(data, 0, sizeof(float) * area * channel);

	for (int ch = 0; ch < channel; ++ch)
	{
		for (int row = 0; row < height; row += stride)
		{
			for (int col = 0; col < width; col += stride)
			{
				float val1 = *tempData;
				float val2 = *(tempData + 1);
				float val3 = *(tempData + width);
				float val4 = *(tempData + width + 1);

				float max = std::max({ val1, val2, val3, val4 });
				*data = max;

				tempData += stride;
				++data;
			}
		}
	}

	inputData->height = outputHeight;
	inputData->width = outputWidth;
	delete[] tempData;
}
void Resize(Tensor* inputData, float scale)
{
	int height = inputData->height;
	int width = inputData->width;
	int channel = inputData->channel;
	int area = height * width;

	int outputHeight = height * scale;
	int outputWidth = width * scale;
	int outputArea = outputHeight * outputWidth;

	float* data = inputData->data;

	float* tempData = new float[area * channel];
	memcpy(tempData, data, sizeof(float) * area * channel);
	memset(data, 0, sizeof(float) * area * channel);


	//for (int i = 0; i < channel * outputArea; ++i)
	//{
	//	_data[i] = 0;
	//}

	for (int ch = 0; ch < channel; ++ch)
	{
		for (int row = 0; row < height; ++row)
		{
			for (int col = 0; col < width; ++col)
			{
				float val = *tempData;

				*data = val;
				*(data + 1) = val;
				*(data + outputWidth) = val;
				*(data + outputWidth + 1) = val;

				data += 2;
				++tempData;
			}
		}
	}

	inputData->height = outputHeight;
	inputData->width = outputWidth;
	delete[] tempData;
}

void Add(Tensor* inputData, Tensor* outputData)
{
	float* data = inputData->data;
	float* _data = outputData->data;

	int size = inputData->width * inputData->height * inputData->channel;

	for (int i = 0; i < size; ++i)
	{
		_data[i] += data[i];
	}
}
void Concat(Tensor* inputData, Tensor* outputData)
{
	float* data = inputData->data;
	float* _data = outputData->data;
	int size = inputData->width * inputData->height * inputData->channel;

	for (int i = size; i < size * 2; ++i)
	{
		data[i] = _data[i - size];
	}
}
